1. Да се създаде абстрактен клас, който да репрезентира секвенция (Sequencе) с необходимите за нея базови полета (name, content) и 3 наследника на този клас за съответните формати ( FASTA, MULTI_FASTA, FASTQ). Полето name служи за идентифициране на секвенцията като ID. Параметъра content трябва да съдържа цялата секвенция както е прочетена от файла. Да се направи абстрактен метод "parse", който да е дефиниран в класа Sequencе и трите наследника да го имплементират по съответния за тях начин. Метода parse за вся секвенция трябва да обработи подадения "content" параметър в конструктура и да извлече от него информацията за сътветната секвенция.
</br>1) Fasta_Sequence - description, sequence като стрингово поле
</br>2) Multi_Fasta_Sequence - колекция от Fasta_Sequence (тук за име на поредната секвенция да се ползва първият стринг между началният таг за секвенция > и първият интервал. В посоченият файл data/multi_fasta.mfa за първата секвенция името трябва да бъде tr|K7EIQ4|K7EIQ4_HUMAN) и поле timestamp с текуща дата, която да показва кога е обработена секвенцията.
</br>3)FastaQ_Sequence - description, sequence, has_quality_value - поле което показва дали има данни за коректност(дали има "+" на ред 3) и quality_value ако има. 
</br>Да се нарпави изброим тип (Enum) който да се казва SequenceType, в който се описват всички поддържани формати на системата (Fasta, Multi_Fasta, FastQ)__
Да се реализира SequenceParser клас, който има метод за  парсване на секвенция, който приема като аргументи seq_type(да се използва създаденият изброим тип), content и seq_name и връща като резултат подходяща инстанция на класа Sequencе. Използвайки класа SequenceParser да се обработят следните файлове - data/fasta.fa, data/multi_fasta.mfa, data/SRR081241.filt.fastq

2. Да се създаде клиент-сървър приложение, като сървъра трябва да слуша на порт 9001 и цялата комуникация се извършва посредством сокети. Сървъра трябва да приема един аргумент seq_type(в какъв тип да върне секвенцията) и да връща секвенцията в избраният формат на клиента. Връщатана секвенция се взима от файл (fasta - data/server_fasta.fa, FastQ - data/server_fastq.fastq) в зависимост от подадения параметър от клиента seq_type. Секвенцията се парсва от сървъра и на клиента се подава единствено секвенцията без допълнителните параметри към нея. След нея се изпраща на клиента терминиращ оператор, който указва, че цялата секвенция е изпратена (може да бъде всякакъв символ или низ, който изберете). Може да се използват парсарите създадени за задача 1. Сървъра трябва да разбира минимум от 2 формата FASTA и FASTQ. При свързване със сървъра клиентът трябва да изпрати seq_type и да чака отговор от сървъра със секвенцията. Сървъра и клиента трябва да изпращат данните на порции по 1024 байта. Клиентът трябва да чака своят резултат в нов Thread. Когато клиента получи пакет от 1024 байта трябва да го раздели на 10 части и за всяка част да се пусне нов Thread, който да пресметне GC съдържанието на подадената му част от секвенция. Клиентът трябва да чака за нов пакет от 1024 байта докато не получи терминиращият параметър, който сте избрали. Резултатът от всички Thread-ове трябва да се сумира и изведе по подходящ начин във файл с име "gc_content.txt".



Относно форматите тук може да се намери информация какви допълнителни полета се съдържат.
</br >Fasta/Multi-Fasta – след този знак > първата дума я приемате за идентификатор на секвенцията (ID или Name) а след нея всичко за description. Самата секвенция за content. https://en.wikipedia.org/wiki/FASTA_format , https://blast.ncbi.nlm.nih.gov/Blast.cgi?CMD=Web&PAGE_TYPE=BlastDocs&DOC_TYPE=BlastHelp , 
</br >FASTQ - https://en.wikipedia.org/wiki/FASTQ_format
</br >Предложение за парсър -  Може да ползвате парсарът, който написахмe в час или някой от готовите библиотеки като https://biopython.org/wiki/SeqIO 

